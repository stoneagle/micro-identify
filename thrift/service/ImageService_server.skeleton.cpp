// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ImageService.h"
#include "clsAPI.h"
#include <iostream>
#include <cv.hpp>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::std;
using namespace ::cv;

using namespace  ::image;

class ImageServiceHandler : virtual public ImageServiceIf {
 public:
  BookReading* book; 
  struct thread_param{
      BookReading* objBR;
      cv::Mat* ptr_img;
      int modelid;
      int coverid;
      int threadID;
  };
  ImageServiceHandler() {
    std::string model_file;
    model_file = "./model";
    if(model_file[model_file.size() - 1] == '/') {
        model_file = model_file.substr(0, model_file.size()-1);
    }
    book = new BookReading(model_file);
  }

  void getIdentify(Response& _return, const Request& request) {
    cv::Mat img = cv::imread(request.imgPath, -1);
    if (img.empty()) {
        _return.bookID = "NoneImg";
        _return.state = ResponseState::StateError;
    } else {
        int modelid = 1;
        thread_param ti;
        ti.objBR = book;
        ti.ptr_img = &img;
        ti.modelid = modelid;
        ti.threadID = 1;
        stru_predrst prediction;
        prediction = ti.objBR->readcover_fixedsize(*(ti.ptr_img));
        _return.bookID = prediction.name;
        _return.state = ResponseState::StateOk;
    }
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::apache::thrift::stdcxx::shared_ptr<ImageServiceHandler> handler(new ImageServiceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new ImageServiceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

